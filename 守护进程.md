## 1. 创建子进程，父进程退出

​		由于守护进程使脱离控制终端的，因此，完成第一步后就会在shell终端里造成一种程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在shell终端里则可以执行其他的命令，从而在形式上做到了与控制终端的脱离。

​		由于父进程创建子进程后退出，子进程会编程一个孤儿进程，自动被1号进程（init进程）收养。

```
pid = fork();
if(pid > 0){
	exit(0);/* 父进程退出 */
}
```



## 2. 在子进程中创建新会话

- 进程组

  进程组是一个或多个进程的集合。进程组由进程组ID来唯一标识。除了进程号（PID）之外，进程组ID也是一个进程的必备属性。

  每个进程组都有一个组长进程，其组长进程的进程号等于进程组ID。且该进程ID不会因组长进程的退出而受到影响。

- 会话期

  会话组是一个或多个进程组的集合。通常，一个会话开始于用户登录，终止于用户退出，在此期间该用户进行的所欲进程都属于这个会话期。

1. setsid()函数作用。

   setsid()函数用于创建一个新的会话，并担任该会话组的组长。调用setsid()有3个作用。

   - 让进程摆脱原会话的控制。
   - 让进程摆脱原进程组的控制。
   - 让进程摆脱原控制终端的控制。

   在第一步，调用fork()函数来创建子进程再令父进程退出。由于在调用fork()函数时，子进程全盘复制了父进程的会话期，进程组和控制终端等，虽然父进程退出了，但原先的会话期，进程组和控制终端等并没有改变，因此，还不是真正意义上的独立，而setsid()函数能够使进程完全独立出来，从而脱离所有其他进程的控制。

2. setsid()函数格式。

   | 所需头文件 | #include<sys/types.h><br />#include<unistd.h> |
   | ---------- | --------------------------------------------- |
   | 函数原型   | pid_t setsid(void)                            |
   | 函数返回值 | 成功：该进程组ID<br />出错：-1                |

## 3. 改变当前目录

​		使用fork()创建的子进程继承了父进程的当前工作目录。由于在进程运行过程中，当前目录所在的文件系统(比如"/mnt/usb"等)是不能卸载的，这对以后的使用会造成诸多的麻烦(比如系统由于某种原因要进入单用户模式)。因此，通常的做法是让"/"作为守护进程的当前工作目录，这样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，改变工作目录的常见函数是chdir()。

## 4. 重设文件权限掩码

​		文件权限掩码是指屏蔽掉文件权限中的对应位，比如，有一个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限。由于使用fork()函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多麻烦，因此，把文件权限掩码设置为0，可以大大增强该守护进程的灵活性。设置文件权限掩码的函数是umask()。

## 5. 关闭文件描述符

​		用fork()函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读或写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法被卸载。

​		在第2步之后，守护进程已经与所属的控制终端失去了联系。因此从终端输入的字符不可能达到守护进程，守护进程中用常规方法输出的字符也不可能在终端上显示出来。所以，文件描述符为0，1，2的三个文件（输入，输出，报错）已经失去了存在的价值，也应被关闭。

```
for(i = 0; i < MAXFILE; i++){
	close(i);
}
```

---

---

```
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<fcntl.h>
#include<sys/types.h>
#include<unistd.h>
#include<sys/wait.h>
int main()
{
	pid_t pid;
	int i, fd;
	char *buf = "This is a Daemon\n";
	pid = fork(); /* 第一步 */
	if (pid < 0)
	{
		printf("Error fork\n");
		exit(1);
	}
	else if (pid > 0)
	{
		exit(0); /* 父进程推出 */
	}
	setsid(); /*第二步*/
	chdir("/"); /*第三步*/
	umask(0); /*第四步*/
	for(i = 0; i < getdtablesize(); i++) /*第五步*/
	{
		close(i);
	}
/*这时创建完守护进程，以下开始正式进入守护进程工作*/
	while(1)
	{
		if ((fd = open("/tmp/daemon.log",
							O_CREAT|O_WRONLY|O_APPEND, 0600)) < 0)
		{
			printf("Open file error\n");
			exit(1);
		}
		write(fd, buf, strlen(buf) + 1);
		close(fd);
		sleep(10);
	}
	exit(0);
}
```



